程序输出有两种方式：
- 即时处理（系统负担大）
- 暂存起来（在哪里存？内存？），再大块写入

一般来说采用第二种方式，在 C 语言中通过库函数 setbuf 实现

*查看过 Rocksdb 中的代码并没有使用 setbuf *

```cpp
#include <stdio.h> 

main() { 
	int c; 
	char buf[BUFSIZ]; 
	setbuf(stdout, buf); 
	while ((c = getchar()) != EOF) 
	putchar(c); 
}
```

这样的程序早咋一看是没有问题的，但是问题出在 char buf 上。
buf 数组的回收在 main 函数结束，但由于使用了 setbuf，在库函数中还会再释放一次。造成了两次内存释放。

解决方案：
- static char buf[]
- 使用 malloc 动态分配，这样在 main 结束时不会主动释放 buf
	- setbuf(stdout, malloc(BUFSIZ))


练习 5 - 2
若不引入 stdio.h 文件，且自定义 EOF，会有什么问题？

```cpp
#define EOF -1 
main() { 
	register int c; 
	while ((c = getchar()) != EOF) 
	putchar(c); 
}
```

getchar 在 stdio.h 中是宏定义，若没有使用 stdio 则会被编译器理解为函数调用，这样运行的速度会很慢。

为什么会在库文件有 getchar 的函数定义：
- 防止编程人员粗心大意
- 方便需要获取 getchar 地址的编程人员